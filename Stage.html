<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Stage — Champ & particules (instantané)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.0/full/pyodide.js"></script>
  <style>
    body{font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;margin:0;padding:16px;background:#fff;color:#111}
    h1{font-family:serif;margin:0 0 12px}
    .controls{display:flex;gap:10px;align-items:center;margin-bottom:12px}
    input[type="number"]{padding:6px;border-radius:6px;border:1px solid #ddd}
    .btn{background:#8b0000;color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    #plot{width:100%;height:720px}
    .small{font-size:13px;color:#666}
    .progress-wrap{height:14px;background:#fff;border:2px solid #ddd;border-radius:4px;overflow:hidden;margin-top:8px}
    .progress-bar{height:100%;width:0;background:#1f77b4}
  </style>
</head>
<body>
  <h1>Simulation — champ & particules (instantané)</h1>

  <div class="controls">
    <button id="run" class="btn">Lancer la simulation</button>
    <label>n_images: <input id="n_image" type="number" value="100" min="5" style="width:80px"></label>
    <label>grid (nx): <input id="grid_nx" type="number" value="100" min="8" style="width:80px"></label>
    <label>grid (ny): <input id="grid_ny" type="number" value="100" min="8" style="width:80px"></label>
    <label>T_final: <input id="Tfinal" type="number" value="100" step="1" style="width:80px"></label>
    <label style="display:flex;align-items:center;gap:6px"><input id="compute_field" type="checkbox" checked> Calculer le champ</label>
    <div style="margin-left:auto"><span id="status" class="small">Prêt — serve via HTTP.</span></div>
  </div>

  <div id="plot"></div>

  <div class="progress-wrap"><div id="progressBar" class="progress-bar"></div></div>

  <div style="display:flex;align-items:center;gap:12px;margin-top:8px">
    <div class="small">Temps : <span id="timeDisplay">—</span> s</div>
    <input id="timeSlider" type="range" min="0" max="0" value="0" step="1" style="flex:1">
    <label style="display:flex;align-items:center;gap:6px">Vitesse:
      <input id="speedRange" type="range" min="10" max="500" value="100" style="width:160px">
    </label>
    <button id="play" class="btn">▶ Play</button>
  </div>

<script>
  // DOM
  const runBtn = document.getElementById('run');
  const statusEl = document.getElementById('status');
  const nImageInput = document.getElementById('n_image');
  const gridNxInput = document.getElementById('grid_nx');
  const gridNyInput = document.getElementById('grid_ny');
  const TfinalInput = document.getElementById('Tfinal');
  const computeFieldCheckbox = document.getElementById('compute_field');
  const plotDiv = document.getElementById('plot');
  const timeSlider = document.getElementById('timeSlider');
  const timeDisplay = document.getElementById('timeDisplay');
  const playBtn = document.getElementById('play');
  const progressBar = document.getElementById('progressBar');
  const speedRange = document.getElementById('speedRange');

  let pyodide = null, pyReady=false;
  let simData = null, playInterval = null, playSpeedMs = 100;

  // helper to unpack flat [x0,y0,x1,y1,...]
  function flatToXY(flat){
    const xs=[], ys=[];
    for(let i=0;i<flat.length;i+=2){ xs.push(flat[i]); ys.push(flat[i+1]); }
    return {xs, ys};
  }

  async function ensurePyodide(){
    if(pyReady) return;
    statusEl.textContent = 'Chargement Pyodide...';
    pyodide = await loadPyodide({indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.0/full/"});
    statusEl.textContent = 'Pyodide chargé — chargement numpy...';
    try { await pyodide.loadPackage(['numpy']); statusEl.textContent='numpy prêt.'; }
    catch(e){
      // fallback micropip
      await pyodide.loadPackage(['micropip']);
      await pyodide.runPythonAsync(`import micropip\nawait micropip.install("numpy")`);
      statusEl.textContent='numpy installé via micropip.';
    }
    pyReady = true;
  }

  async function fetchAndInjectSimulation(){
    statusEl.textContent = 'Récupération simulation.py ...';
    const r = await fetch('simulation.py', {cache:'no-store'});
    if(!r.ok){ statusEl.textContent = 'Erreur fetch simulation.py: ' + r.status; throw new Error('fetch'); }
    const txt = await r.text();
    statusEl.textContent = 'Injection du code Python...';
    await pyodide.runPythonAsync(txt);
    statusEl.textContent = 'Code Python injecté.';
  }

  async function callSim(n_image, grid_nx, grid_ny, Tfinal, compute_field){
    statusEl.textContent = 'Exécution simulate(...) (peut être long)...';
    progressBar.style.width = '2%';
    const dt = Tfinal / Math.max(1, (n_image - 1));
    const pyCall = `
import json
res = simulate(steps=None, dt=${dt}, n_image_local=${n_image}, grid_nx_field=${grid_nx}, grid_ny_field=${grid_ny}, grid_extent_local=5.0, compute_field=${compute_field})
json.dumps(res)
`;
    const jsonStr = await pyodide.runPythonAsync(pyCall);
    progressBar.style.width = '100%';
    return JSON.parse(jsonStr);
  }

  function initPlot(data){
    simData = data;
    // field (contour + quiver background)
    const hasField = Array.isArray(data.Ux_fields) && data.Ux_fields.length>0 && data.Ux_fields[0].length>0;
    const traces = [];

    if(hasField){
      const grid_nx = data.grid_nx, grid_ny = data.grid_ny;
      // contour magnitude (frame 0)
      const z = [];
      for(let j=0;j<grid_ny;j++){
        const row = [];
        for(let i=0;i<grid_nx;i++){
          const idx = j*grid_nx + i;
          row.push(Math.hypot(data.Ux_fields[0][idx], data.Uy_fields[0][idx]));
        }
        z.push(row);
      }
      traces.push({
        z:z, x:data.grid_x, y:data.grid_y, type:'contour',
        colorscale:'Plasma', contours:{coloring:'lines'}, showscale:true, colorbar:{title:'|u|',thickness:20}
      });

      // background quiver (sampled)
      const stride = Math.max(1, Math.floor(grid_nx / 20));
      const qx=[], qy=[], quvx=[], quvy=[];
      for(let j=0;j<grid_ny;j+=stride){
        for(let i=0;i<grid_nx;i+=stride){
          const idx=j*grid_nx + i;
          qx.push(data.grid_x[i]); qy.push(data.grid_y[j]);
          quvx.push(data.Ux_fields[0][idx]); quvy.push(data.Uy_fields[0][idx]);
        }
      }
      // convert quiver to line segments for Plotly
      const ax=[], ay=[], axh=[], ayh=[];
      const scale = 0.25 * Math.max(Math.abs(data.grid_x[1]-data.grid_x[0]), Math.abs(data.grid_y[1]-data.grid_y[0]));
      for(let k=0;k<qx.length;k++){
        const x0=qx[k], y0=qy[k];
        const x1=x0 + scale*quvx[k], y1=y0 + scale*quvy[k];
        ax.push(x0); ax.push(x1); ax.push(null);
        ay.push(y0); ay.push(y1); ay.push(null);
        axh.push(x1); ayh.push(y1);
      }
      traces.push({ x:ax, y:ay, mode:'lines', line:{color:'rgb(45,32,110)', width:1.2}, hoverinfo:'none', showlegend:false });
      traces.push({ x:axh, y:ayh, mode:'markers', marker:{size:5,symbol:'triangle-up',color:'rgb(45,32,110)'}, hoverinfo:'none', showlegend:false });
    }

    // particles markers (only instantaneous positions)
    const frame0 = data.qs_hist[0];
    const {xs:px0, ys:py0} = flatToXY(frame0);
    traces.push({ x: px0, y: py0, mode:'markers', marker:{size:8,color:'red'}, name:'particles', hoverinfo:'text' });

    // particle velocity arrows (lines + heads) computed from u_selfs[0]
    const u0 = data.u_selfs[0];
    const ax_p=[], ay_p=[], headx=[], heady=[];
    for(let i=0;i<frame0.length;i+=2){
      const x0=frame0[i], y0=frame0[i+1];
      const vx=u0[i], vy=u0[i+1];
      const x1 = x0 + 0.6 * vx, y1 = y0 + 0.6 * vy;
      ax_p.push(x0); ax_p.push(x1); ax_p.push(null);
      ay_p.push(y0); ay_p.push(y1); ay_p.push(null);
      headx.push(x1); heady.push(y1);
    }
    traces.push({ x:ax_p, y:ay_p, mode:'lines', line:{color:'red', width:2.0}, hoverinfo:'none', showlegend:false });
    traces.push({ x:headx, y:heady, mode:'markers', marker:{size:6,symbol:'triangle-up',color:'red'}, hoverinfo:'none', showlegend:false });

    const layout = {
      title: 'Champ |u| + particules (instantané)',
      margin:{t:40,l:60,r:80,b:60},
      xaxis:{title:'x'}, yaxis:{title:'y',scaleanchor:'x',scaleratio:1}
    };

    Plotly.newPlot(plotDiv, traces, layout, {responsive:true});
    // slider setup
    timeSlider.min = 0;
    timeSlider.max = Math.max(0, data.t.length - 1);
    timeSlider.value = 0;
    timeDisplay.textContent = data.t[0].toFixed(2);
  }

  function updateFrame(idx){
    if(!simData) return;
    const data = simData;
    const frame = data.qs_hist[idx];
    const u = data.u_selfs[idx];

    // update contour & background quiver if available
    const hasField = Array.isArray(data.Ux_fields) && data.Ux_fields.length>0 && data.Ux_fields[0].length>0;
    if(hasField){
      const grid_nx = data.grid_nx, grid_ny = data.grid_ny;
      const Ux = data.Ux_fields[idx], Uy = data.Uy_fields[idx];
      // update contour magnitude
      const z = [];
      for(let j=0;j<grid_ny;j++){
        const row=[];
        for(let i=0;i<grid_nx;i++){
          const id=j*grid_nx + i;
          row.push(Math.hypot(Ux[id], Uy[id]));
        }
        z.push(row);
      }
      Plotly.restyle(plotDiv, {'z':[z]}, [0]); // trace 0 = contour
      // update sampled quiver (trace 1 lines + 2 heads)
      const stride = Math.max(1, Math.floor(grid_nx / 20));
      const ax=[], ay=[], hx=[], hy=[];
      const scale = 0.25 * Math.max(Math.abs(data.grid_x[1]-data.grid_x[0]), Math.abs(data.grid_y[1]-data.grid_y[0]));
      for(let j=0;j<grid_ny;j+=stride){
        for(let i=0;i<grid_nx;i+=stride){
          const id=j*grid_nx + i;
          const x0=data.grid_x[i], y0=data.grid_y[j];
          const x1=x0 + scale * Ux[id], y1=y0 + scale * Uy[id];
          ax.push(x0); ax.push(x1); ax.push(null);
          ay.push(y0); ay.push(y1); ay.push(null);
          hx.push(x1); hy.push(y1);
        }
      }
      Plotly.restyle(plotDiv, {'x':[ax],'y':[ay]}, [1]); // background arrow lines
      Plotly.restyle(plotDiv, {'x':[hx],'y':[hy]}, [2]); // background arrow heads
    }

    // update particle positions (last traces are: particles marker, particle arrow lines, particle arrow heads)
    // find index of particle marker trace: if hasField => last index = 3? we built traces accordingly
    // compute base index:
    const has = hasField ? 3 : 0; // if hasField true, before particles we had 3 traces (contour + q lines + q heads)
    // particle marker trace index:
    const markerIdx = has;
    const arrowLinesIdx = has + 1;
    const arrowHeadsIdx = has + 2;

    const {xs, ys} = flatToXY(frame);
    Plotly.restyle(plotDiv, { 'x':[xs], 'y':[ys] }, [markerIdx]);

    // particle arrows:
    const ax_p=[], ay_p=[], hx_p=[], hy_p=[];
    for(let i=0;i<frame.length;i+=2){
      const x0=frame[i], y0=frame[i+1];
      const vx = u[i], vy = u[i+1];
      const x1 = x0 + 0.6 * vx, y1 = y0 + 0.6 * vy;
      ax_p.push(x0); ax_p.push(x1); ax_p.push(null);
      ay_p.push(y0); ay_p.push(y1); ay_p.push(null);
      hx_p.push(x1); hy_p.push(y1);
    }
    Plotly.restyle(plotDiv, {'x':[ax_p],'y':[ay_p]}, [arrowLinesIdx]);
    Plotly.restyle(plotDiv, {'x':[hx_p],'y':[hy_p]}, [arrowHeadsIdx]);

    // update slider/time
    timeSlider.value = idx;
    timeDisplay.textContent = data.t[idx].toFixed(2);
  }

  // slider + play handlers
  timeSlider.addEventListener('input', (e)=> updateFrame(parseInt(e.target.value)));
  speedRange.addEventListener('input', ()=> {
    const v = parseInt(speedRange.value);
    playSpeedMs = Math.max(10, Math.round(1100 - 2 * v));
  });

  playBtn.addEventListener('click', ()=>{
    if(!simData) return;
    if(playInterval){
      clearInterval(playInterval);
      playInterval = null;
      playBtn.textContent = '▶ Play';
      return;
    }
    playBtn.textContent = '⏸ Pause';
    const maxIdx = simData.t.length - 1;
    playInterval = setInterval(()=>{
      let idx = parseInt(timeSlider.value);
      idx = (idx < maxIdx) ? idx + 1 : 0;
      updateFrame(idx);
    }, playSpeedMs);
  });

  // Run sequence
  runBtn.addEventListener('click', async ()=>{
    runBtn.disabled = true;
    progressBar.style.width = '2%';
    try {
      const n_image = parseInt(nImageInput.value) || 100;
      const grid_nx = parseInt(gridNxInput.value) || 100;
      const grid_ny = parseInt(gridNyInput.value) || 100;
      const Tfinal = parseFloat(TfinalInput.value) || 100.0;
      const compute_field = computeFieldCheckbox.checked ? 'True' : 'False';

      await ensurePyodide();
      await fetchAndInjectSimulation();
      statusEl.textContent = 'Calcul en cours (Python) — ceci peut prendre du temps...';
      const data = await callSim(n_image, grid_nx, grid_ny, Tfinal, compute_field);
      statusEl.textContent = 'Simulation calculée — rendu...';
      initPlot(data);
      updateFrame(0);
      statusEl.textContent = 'Terminé — utilisez le slider ou Play.';
      progressBar.style.width = '100%';
    } catch(e){
      console.error(e);
      statusEl.textContent = 'Erreur : ' + (e.message || e);
      progressBar.style.width = '0%';
    } finally {
      runBtn.disabled = false;
    }
  });
</script>
</body>
</html>
