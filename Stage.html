<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Stage — Simulation (animation)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Merriweather:wght@300;700&display=swap" rel="stylesheet">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.0/full/pyodide.js"></script>
  <style>
    :root{--maxw:900px;--brand:#8b0000;--line:#e5e7eb;--muted:#6b7280}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:#fff;color:#111827}
    header{background:var(--brand);padding:14px 0;color:#fff}
    .wrap{max-width:var(--maxw);margin:0 auto;padding:0 20px;display:flex;align-items:center;justify-content:space-between}
    h1{font-family:Merriweather,serif;margin:0;font-size:18px}
    main{max-width:var(--maxw);margin:28px auto;padding:0 20px}
    .card{border:1px solid var(--line);border-radius:8px;padding:16px;background:#fff}
    .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:12px}
    input[type="number"]{padding:6px;border:1px solid #ddd;border-radius:6px}
    .btn{background:var(--brand);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .status{color:var(--muted);font-size:13px;margin-bottom:8px}
    #plotField,#plotParticles{width:100%;height:420px;margin-top:10px}
    .slider-row{display:flex;align-items:center;gap:12px;margin-top:10px}
    .time-label{color:var(--muted);min-width:80px}
  </style>
</head>
<body>
<header><div class="wrap"><h1>Blog de l'intranquilité — Stage</h1></div></header>

<main>
  <section class="card">
    <h2 style="font-family:Merriweather,serif;margin:0 0 10px">Simulation & animation</h2>

    <div class="controls">
      <button id="run" class="btn">Lancer la simulation</button>

      <label>n_images:
        <input id="n_image" type="number" value="60" min="5" style="width:90px">
      </label>

      <label>grid (nx):
        <input id="grid_nx" type="number" value="40" min="8" style="width:80px">
      </label>

      <label>grid (ny):
        <input id="grid_ny" type="number" value="40" min="8" style="width:80px">
      </label>

      <label>T_final:
        <input id="Tfinal" type="number" value="30" step="1" style="width:90px">
      </label>

      <div style="flex:1;text-align:right"><span id="status" class="status">Prêt — place Stage.html et simulation.py dans le même dossier, servez via HTTP.</span></div>
    </div>

    <div id="plotField"></div>
    <div id="plotParticles" style="margin-top:10px"></div>

    <div class="slider-row">
      <div class="time-label">Temps : <span id="timeDisplay">—</span> s</div>
      <input id="timeSlider" type="range" min="0" max="0" value="0" step="1" style="flex:1">
      <button id="play" class="btn" style="width:90px">▶ Play</button>
    </div>
  </section>
</main>

<script>
  // DOM
  const runBtn = document.getElementById('run');
  const statusEl = document.getElementById('status');
  const nImageInput = document.getElementById('n_image');
  const gridNxInput = document.getElementById('grid_nx');
  const gridNyInput = document.getElementById('grid_ny');
  const TfinalInput = document.getElementById('Tfinal');

  const plotFieldDiv = document.getElementById('plotField');
  const plotParticlesDiv = document.getElementById('plotParticles');

  const timeSlider = document.getElementById('timeSlider');
  const timeDisplay = document.getElementById('timeDisplay');
  const playBtn = document.getElementById('play');

  let pyodide = null, pyReady = false;
  let simData = null, stored=null, playInterval=null;

  async function ensurePyodide(){
    if(pyReady) return;
    statusEl.textContent = 'Chargement Pyodide & numpy...';
    pyodide = await loadPyodide();
    // numpy is commonly available but ensure package loaded
    try { await pyodide.loadPackage(['numpy']); } catch(e){ console.warn('loadPackage numpy failed',e); }
    pyReady = true;
    statusEl.textContent = 'Pyodide prêt.';
  }

  async function fetchAndInjectSimulation(){
    statusEl.textContent = 'Récupération simulation.py ...';
    const r = await fetch('simulation.py', {cache:'no-store'});
    if(!r.ok){ statusEl.textContent = 'Erreur fetch simulation.py: HTTP ' + r.status; throw new Error('fetch error'); }
    const txt = await r.text();
    statusEl.textContent = 'Injection du code...';
    await pyodide.runPythonAsync(txt);
    statusEl.textContent = 'Code injecté.';
  }

  async function callSim(n_image, grid_nx, grid_ny, Tfinal){
    statusEl.textContent = 'Exécution simulate(...) (peut prendre du temps)...';
    // prepare call: call simulate(n_image=n_image, dt=Tfinal/(n_image-1), grid_nx_field=grid_nx, grid_ny_field=grid_ny)
    const dt = Tfinal / Math.max(1, (n_image - 1));
    const pyCall = `
import json
res = simulate(n_image_local=${n_image}, dt=${dt}, grid_nx_field=${grid_nx}, grid_ny_field=${grid_ny}, grid_extent_local=5.0)
json.dumps(res)
`;
    const jsonStr = await pyodide.runPythonAsync(pyCall);
    return JSON.parse(jsonStr);
  }

  function initPlots(data){
    // data: { t, qs_hist, u_selfs, Ufields, grid_x, grid_y, N, n_image }
    simData = data;
    const t = data.t;
    const n_image = data.n_image;
    const N = data.N;
    const grid_x = data.grid_x;
    const grid_y = data.grid_y;
    // first frame
    const frame0_U = data.Ufields[0]; // length grid_nx*grid_ny
    const grid_nx = data.grid_nx;
    const grid_ny = data.grid_ny;
    // reshape z
    const z0 = [];
    for(let j=0;j<grid_ny;j++){
      z0.push(frame0_U.slice(j*grid_nx, (j+1)*grid_nx));
    }

    // field heatmap (use grid_x, grid_y order)
    const heat = {
      z: z0,
      x: grid_x,
      y: grid_y,
      type: 'heatmap',
      colorscale: 'Viridis',
      colorbar: { title: '|u|' }
    };

    Plotly.newPlot(plotFieldDiv, [heat], { title: 'Champ |u| (background)', margin:{t:30}, xaxis:{title:'x'}, yaxis:{title:'y',scaleanchor:'x',scaleratio:1} }, {responsive:true});

    // particles scatter (initial)
    const frame0_qs = data.qs_hist[0]; // flattened [x1,y1,x2,y2,...]
    const xs = [], ys = [];
    for(let i=0;i<frame0_qs.length;i+=2){ xs.push(frame0_qs[i]); ys.push(frame0_qs[i+1]); }
    const particles = { x: xs, y: ys, mode:'markers', marker:{size:8,color:'red'}, name:'particles' };

    // velocity arrows as line segments concatenated (x0,x1,null, x0_2,x1_2,null, ...)
    function buildArrowSegments(qs_flat, us_flat, scale=0.5){
      const ax = [], ay = [];
      for(let i=0;i<qs_flat.length;i+=2){
        const x0 = qs_flat[i], y0 = qs_flat[i+1];
        const vx = us_flat[i], vy = us_flat[i+1];
        const x1 = x0 + scale * vx;
        const y1 = y0 + scale * vy;
        ax.push(x0); ax.push(x1); ax.push(null);
        ay.push(y0); ay.push(y1); ay.push(null);
      }
      return { x:ax, y:ay };
    }
    const frame0_u = data.u_selfs[0];
    const arrowSeg = buildArrowSegments(frame0_qs, frame0_u, 0.6);
    const arrows = { x: arrowSeg.x, y: arrowSeg.y, mode:'lines', line:{color:'black',width:2}, hoverinfo:'none', showlegend:false };

    Plotly.newPlot(plotParticlesDiv, [particles, arrows], { title:'Positions & vitesses locales', margin:{t:30}, xaxis:{title:'x'}, yaxis:{title:'y',scaleanchor:'x',scaleratio:1} }, {responsive:true});

    // slider setup
    timeSlider.min = 0;
    timeSlider.max = Math.max(0, t.length - 1);
    timeSlider.value = 0;
    timeDisplay.textContent = t[0].toFixed(3);

    // store for updates
    stored = { t, N, grid_nx, grid_ny };
  }

  function updateFrame(idx){
    if(!simData) return;
    const data = simData;
    const t = data.t;
    // update field heatmap
    const grid_nx = data.grid_nx;
    const grid_ny = data.grid_ny;
    const frameU = data.Ufields[idx];
    const z = [];
    for(let j=0;j<grid_ny;j++){
      z.push(frameU.slice(j*grid_nx, (j+1)*grid_nx));
    }
    Plotly.restyle(plotFieldDiv, {'z':[z]});

    // update particles
    const qs = data.qs_hist[idx];
    const us = data.u_selfs[idx];
    const xs = [], ys = [];
    for(let i=0;i<qs.length;i+=2){ xs.push(qs[i]); ys.push(qs[i+1]); }
    Plotly.restyle(plotParticlesDiv, {'x':[xs], 'y':[ys]}, [0]);

    // update arrows
    const arrowSeg = (function(){
      const ax=[], ay=[];
      for(let i=0;i<qs.length;i+=2){
        const x0 = qs[i], y0 = qs[i+1];
        const vx = us[i], vy = us[i+1];
        const x1 = x0 + 0.6 * vx;
        const y1 = y0 + 0.6 * vy;
        ax.push(x0); ax.push(x1); ax.push(null);
        ay.push(y0); ay.push(y1); ay.push(null);
      }
      return {x:ax, y:ay};
    })();
    Plotly.restyle(plotParticlesDiv, {'x':[arrowSeg.x], 'y':[arrowSeg.y]}, [1]);

    // update slider display
    timeSlider.value = idx;
    timeDisplay.textContent = t[idx].toFixed(3);
  }

  timeSlider.addEventListener('input', (e) => {
    const idx = parseInt(e.target.value);
    updateFrame(idx);
  });

  playBtn.addEventListener('click', () => {
    if(!simData) return;
    if(playInterval){
      clearInterval(playInterval);
      playInterval = null;
      playBtn.textContent = '▶ Play';
      return;
    }
    playBtn.textContent = '⏸ Pause';
    const maxIdx = simData.t.length - 1;
    playInterval = setInterval(() => {
      let idx = parseInt(timeSlider.value);
      idx = (idx < maxIdx) ? idx + 1 : 0;
      updateFrame(idx);
    }, 100);
  });

  // Run sequence
  runBtn.addEventListener('click', async () => {
    runBtn.disabled = true;
    try {
      const n_image = parseInt(nImageInput.value) || 60;
      const grid_nx = parseInt(gridNxInput.value) || 40;
      const grid_ny = parseInt(gridNyInput.value) || 40;
      const Tfinal = parseFloat(TfinalInput.value) || 30.0;

      await ensurePyodide();
      await fetchAndInjectSimulation();
      const data = await callSim(n_image, grid_nx, grid_ny, Tfinal);
      statusEl.textContent = 'Simulation calculée en Python — rendu...';
      initPlots(data);
      updateFrame(0);
      statusEl.textContent = 'Terminé — utilisez le slider ou Play.';
    } catch (e){
      console.error(e);
      statusEl.textContent = 'Erreur : ' + (e.message || e);
    } finally {
      runBtn.disabled = false;
    }
  });

</script>
</body>
</html>
