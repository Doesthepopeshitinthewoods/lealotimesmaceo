<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Stage — Simulation (animation)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Merriweather:wght@300;700&display=swap" rel="stylesheet">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.0/full/pyodide.js"></script>
  <style>
    :root{--maxw:900px;--brand:#8b0000;--line:#e5e7eb;--muted:#6b7280}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:#fff;color:#111827}
    header{background:var(--brand);padding:14px 0;color:#fff}
    .wrap{max-width:var(--maxw);margin:0 auto;padding:0 20px;display:flex;align-items:center;justify-content:space-between}
    h1{font-family:Merriweather,serif;margin:0;font-size:18px}
    main{max-width:var(--maxw);margin:28px auto;padding:0 20px}
    .card{border:1px solid var(--line);border-radius:8px;padding:16px;background:#fff}
    .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:12px}
    input[type="number"]{padding:6px;border:1px solid #ddd;border-radius:6px}
    .btn{background:var(--brand);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .status{color:var(--muted);font-size:13px;margin-bottom:8px}
    #plotField,#plotParticles{width:100%;height:420px;margin-top:10px}
    .slider-row{display:flex;align-items:center;gap:12px;margin-top:10px}
    .time-label{color:var(--muted);min-width:80px}
    .small{font-size:13px;color:var(--muted)}
  </style>
</head>
<body>
<header><div class="wrap"><h1>Blog de l'intranquilité — Stage</h1></div></header>

<main>
  <section class="card">
    <h2 style="font-family:Merriweather,serif;margin:0 0 10px">Simulation & animation — 25 particules (jetlet niveau 0)</h2>

    <div class="controls">
      <button id="run" class="btn">Lancer la simulation</button>

      <label>n_images:
        <input id="n_image" type="number" value="30" min="5" style="width:90px">
      </label>

      <label>grid (nx):
        <input id="grid_nx" type="number" value="16" min="8" style="width:80px">
      </label>

      <label>grid (ny):
        <input id="grid_ny" type="number" value="16" min="8" style="width:80px">
      </label>

      <label>T_final:
        <input id="Tfinal" type="number" value="10" step="1" style="width:90px">
      </label>

      <label style="display:flex;align-items:center;gap:6px" title="Si décoché, on ne calcule pas le champ sur la grille (beaucoup plus rapide)">
        <input id="compute_field" type="checkbox" style="width:16px;height:16px"> Calculer le champ (lent)
      </label>

      <div style="flex:1;text-align:right"><span id="status" class="status">Prêt — place Stage.html et simulation.py dans le même dossier, servez via HTTP.</span></div>
    </div>

    <div id="plotField"></div>
    <div id="plotParticles" style="margin-top:10px"></div>

    <div class="slider-row">
      <div class="time-label">Temps : <span id="timeDisplay">—</span> s</div>
      <input id="timeSlider" type="range" min="0" max="0" value="0" step="1" style="flex:1">
      <button id="play" class="btn" style="width:90px">▶ Play</button>
    </div>

    <div style="margin-top:8px" class="small">Remarque : par défaut la simulation évolue 25 particules (5×5) avec vitesses initiales aléatoires — c'est le niveau « jetlet 0 ».</div>
  </section>
</main>

<script>
  // DOM
  const runBtn = document.getElementById('run');
  const statusEl = document.getElementById('status');
  const nImageInput = document.getElementById('n_image');
  const gridNxInput = document.getElementById('grid_nx');
  const gridNyInput = document.getElementById('grid_ny');
  const TfinalInput = document.getElementById('Tfinal');
  const computeFieldCheckbox = document.getElementById('compute_field');

  const plotFieldDiv = document.getElementById('plotField');
  const plotParticlesDiv = document.getElementById('plotParticles');

  const timeSlider = document.getElementById('timeSlider');
  const timeDisplay = document.getElementById('timeDisplay');
  const playBtn = document.getElementById('play');

  let pyodide = null, pyReady = false;
  let simData = null, stored=null, playInterval=null;

  async function ensurePyodide(){
    if(pyReady) return;
    statusEl.textContent = 'Chargement Pyodide...';
    pyodide = await loadPyodide({indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.0/full/"});
    statusEl.textContent = 'Pyodide chargé — préparation de numpy...';
    try {
      await pyodide.loadPackage(['numpy']);
      statusEl.textContent = 'numpy chargé via loadPackage.';
    } catch (e) {
      console.warn('loadPackage numpy failed, fallback to micropip', e);
      try { await pyodide.loadPackage(['micropip']); } catch(err){}
      try {
        await pyodide.runPythonAsync(`
import micropip
await micropip.install("numpy")
`);
        statusEl.textContent = 'numpy installé via micropip.';
      } catch(err2){
        console.error('Impossible d\'installer numpy via micropip:', err2);
        statusEl.textContent = 'Erreur: impossible d\'installer numpy: ' + (err2.message || err2);
        throw err2;
      }
    }
    pyReady = true;
    statusEl.textContent = 'Pyodide & numpy prêts.';
  }

  async function fetchAndInjectSimulation(){
    statusEl.textContent = 'Récupération simulation.py ...';
    const r = await fetch('simulation.py', {cache:'no-store'});
    if(!r.ok){ statusEl.textContent = 'Erreur fetch simulation.py: HTTP ' + r.status; throw new Error('fetch error'); }
    const txt = await r.text();
    statusEl.textContent = 'Injection du code Python...';
    try {
      await pyodide.runPythonAsync(txt);
      statusEl.textContent = 'Code Python injecté.';
    } catch(err){
      console.error('Erreur lors de l\'injection/exécution de simulation.py', err);
      statusEl.textContent = 'Erreur exécution simulation.py: ' + (err.message || err);
      throw err;
    }
  }

  async function callSim(n_image, grid_nx, grid_ny, Tfinal, compute_field){
    statusEl.textContent = 'Exécution simulate(...) (peut prendre du temps)...';
    const dt = Tfinal / Math.max(1, (n_image - 1));
    const pyCall = `
import json
res = simulate(steps=None, dt=${dt}, n_image_local=${n_image}, grid_nx_field=${grid_nx}, grid_ny_field=${grid_ny}, grid_extent_local=5.0, compute_field=${compute_field})
json.dumps(res)
`;
    const jsonStr = await pyodide.runPythonAsync(pyCall);
    return JSON.parse(jsonStr);
  }

  function initPlots(data){
    simData = data;
    // if no Ufields (empty lists), hide plotField
    const hasField = Array.isArray(data.Ufields) && data.Ufields.length>0 && data.Ufields[0].length > 0;
    if(!hasField){
      plotFieldDiv.style.display = 'none';
    } else {
      plotFieldDiv.style.display = 'block';
      const grid_nx = data.grid_nx, grid_ny = data.grid_ny;
      const frame0_U = data.Ufields[0];
      const z0 = [];
      for(let j=0;j<grid_ny;j++){
        z0.push(frame0_U.slice(j*grid_nx, (j+1)*grid_nx));
      }
      const heat = { z:z0, x: data.grid_x, y: data.grid_y, type:'heatmap', colorscale:'Viridis', colorbar:{title:'|u|'} };
      Plotly.newPlot(plotFieldDiv, [heat], { title: 'Champ |u| (background)', margin:{t:30}, xaxis:{title:'x'}, yaxis:{title:'y',scaleanchor:'x',scaleratio:1} }, {responsive:true});
    }

    // particles scatter (initial)
    const frame0_qs = data.qs_hist[0]; // flattened [x1,y1,...]
    const xs = [], ys = [];
    for(let i=0;i<frame0_qs.length;i+=2){ xs.push(frame0_qs[i]); ys.push(frame0_qs[i+1]); }
    const particles = { x: xs, y: ys, mode:'markers', marker:{size:8,color:'red'}, name:'particles' };

    // arrows
    const frame0_u = data.u_selfs[0];
    function buildArrowSegments(qs_flat, us_flat, scale=0.6){
      const ax = [], ay = [];
      for(let i=0;i<qs_flat.length;i+=2){
        const x0 = qs_flat[i], y0 = qs_flat[i+1];
        const vx = us_flat[i], vy = us_flat[i+1];
        const x1 = x0 + scale * vx;
        const y1 = y0 + scale * vy;
        ax.push(x0); ax.push(x1); ax.push(null);
        ay.push(y0); ay.push(y1); ay.push(null);
      }
      return { x:ax, y:ay };
    }
    const arrowSeg = buildArrowSegments(frame0_qs, frame0_u, 0.6);
    const arrows = { x:arrowSeg.x, y:arrowSeg.y, mode:'lines', line:{color:'black',width:2}, hoverinfo:'none', showlegend:false };

    Plotly.newPlot(plotParticlesDiv, [particles, arrows], { title:'Positions & vitesses locales', margin:{t:30}, xaxis:{title:'x'}, yaxis:{title:'y',scaleanchor:'x',scaleratio:1} }, {responsive:true});

    // slider setup
    const t = data.t;
    timeSlider.min = 0;
    timeSlider.max = Math.max(0, t.length - 1);
    timeSlider.value = 0;
    timeDisplay.textContent = t[0].toFixed(3);

    stored = { t };
  }

  function updateFrame(idx){
    if(!simData) return;
    const data = simData;
    const t = data.t;
    // update field if present
    const hasField = Array.isArray(data.Ufields) && data.Ufields.length>0 && data.Ufields[0].length > 0;
    if(hasField){
      const grid_nx = data.grid_nx, grid_ny = data.grid_ny;
      const frameU = data.Ufields[idx];
      const z = [];
      for(let j=0;j<grid_ny;j++){
        z.push(frameU.slice(j*grid_nx, (j+1)*grid_nx));
      }
      Plotly.restyle(plotFieldDiv, {'z':[z]});
    }

    // update particles
    const qs = data.qs_hist[idx];
    const us = data.u_selfs[idx];
    const xs = [], ys = [];
    for(let i=0;i<qs.length;i+=2){ xs.push(qs[i]); ys.push(qs[i+1]); }
    Plotly.restyle(plotParticlesDiv, {'x':[xs], 'y':[ys]}, [0]);

    // update arrows
    const arrowSeg = (function(){
      const ax=[], ay=[];
      for(let i=0;i<qs.length;i+=2){
        const x0 = qs[i], y0 = qs[i+1];
        const vx = us[i], vy = us[i+1];
        const x1 = x0 + 0.6 * vx;
        const y1 = y0 + 0.6 * vy;
        ax.push(x0); ax.push(x1); ax.push(null);
        ay.push(y0); ay.push(y1); ay.push(null);
      }
      return {x:ax, y:ay};
    })();
    Plotly.restyle(plotParticlesDiv, {'x':[arrowSeg.x], 'y':[arrowSeg.y]}, [1]);

    // update slider display
    timeSlider.value = idx;
    timeDisplay.textContent = t[idx].toFixed(3);
  }

  timeSlider.addEventListener('input', (e) => {
    const idx = parseInt(e.target.value);
    updateFrame(idx);
  });

  playBtn.addEventListener('click', () => {
    if(!simData) return;
    if(playInterval){
      clearInterval(playInterval);
      playInterval = null;
      playBtn.textContent = '▶ Play';
      return;
    }
    playBtn.textContent = '⏸ Pause';
    const maxIdx = simData.t.length - 1;
    playInterval = setInterval(() => {
      let idx = parseInt(timeSlider.value);
      idx = (idx < maxIdx) ? idx + 1 : 0;
      updateFrame(idx);
    }, 100);
  });

  // Run sequence
  runBtn.addEventListener('click', async () => {
    runBtn.disabled = true;
    try {
      const n_image = parseInt(nImageInput.value) || 30;
      const grid_nx = parseInt(gridNxInput.value) || 16;
      const grid_ny = parseInt(gridNyInput.value) || 16;
      const Tfinal = parseFloat(TfinalInput.value) || 10.0;
      const compute_field = computeFieldCheckbox.checked ? 'True' : 'False';

      await ensurePyodide();
      await fetchAndInjectSimulation();
      const data = await callSim(n_image, grid_nx, grid_ny, Tfinal, compute_field);
      statusEl.textContent = 'Simulation calculée en Python — rendu...';
      initPlots(data);
      updateFrame(0);
      statusEl.textContent = 'Terminé — utilisez le slider ou Play.';
    } catch (e){
      console.error(e);
      statusEl.textContent = 'Erreur : ' + (e.message || e);
    } finally {
      runBtn.disabled = false;
    }
  });

</script>
</body>
</html>
