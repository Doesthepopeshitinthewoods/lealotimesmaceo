<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Stage — Simulation (visuel stream/jetlets 0)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Merriweather:wght@300;700&display=swap" rel="stylesheet">
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.0/full/pyodide.js"></script>
  <style>
    :root{--maxw:980px;--brand:#8b0000;--line:#e5e7eb;--muted:#6b7280}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:#fff;color:#111827}
    header{background:var(--brand);padding:12px 0;color:#fff}
    .wrap{max-width:var(--maxw);margin:0 auto;padding:0 20px;display:flex;align-items:center;justify-content:space-between}
    h1{font-family:Merriweather,serif;margin:0;font-size:18px}
    main{max-width:var(--maxw);margin:18px auto;padding:0 20px}
    .card{border:1px solid var(--line);border-radius:8px;padding:12px;background:#fff}
    .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:12px}
    input[type="number"]{padding:6px;border:1px solid #ddd;border-radius:6px}
    .btn{background:var(--brand);color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .status{color:var(--muted);font-size:13px;margin-bottom:8px}
    #plotField,#plotParticles{width:100%;height:600px;margin-top:10px}
    .slider-row{display:flex;align-items:center;gap:12px;margin-top:10px}
    .time-label{color:var(--muted);min-width:80px}
    .small{font-size:13px;color:var(--muted)}
    /* barre de progression large */
    .progress-wrap{height:18px;background:#fff;border:3px solid #ddd;border-radius:4px;overflow:hidden}
    .progress-bar{height:100%;width:0%;background:#1f77b4}
    .controls-right{margin-left:auto;display:flex;align-items:center;gap:8px}
  </style>
</head>
<body>
<header><div class="wrap"><h1>Blog de l'intranquilité — Stage</h1></div></header>

<main>
  <section class="card">
    <h2 style="font-family:Merriweather,serif;margin:0 0 8px">Simulation — jetlets 0 (25 particules)</h2>

    <div class="controls">
      <button id="run" class="btn">Lancer la simulation</button>

      <label>n_images:
        <input id="n_image" type="number" value="30" min="5" style="width:80px">
      </label>

      <label>grid (nx):
        <input id="grid_nx" type="number" value="32" min="8" style="width:70px">
      </label>

      <label>grid (ny):
        <input id="grid_ny" type="number" value="32" min="8" style="width:70px">
      </label>

      <label>T_final:
        <input id="Tfinal" type="number" value="10" step="1" style="width:80px">
      </label>

      <label style="display:flex;align-items:center;gap:6px" title="Si décoché, pas de calcul du champ (beaucoup plus rapide)">
        <input id="compute_field" type="checkbox" checked style="width:16px;height:16px"> Calculer le champ
      </label>

      <div class="controls-right">
        <div style="text-align:right"><span id="status" class="status">Prêt — place Stage.html et simulation.py dans le même dossier, servez via HTTP.</span></div>
      </div>
    </div>

    <div id="plotField"></div>
    <div id="plotParticles" style="margin-top:10px"></div>

    <div style="margin-top:10px">
      <div class="progress-wrap" title="Progression calcul">
        <div id="progressBar" class="progress-bar"></div>
      </div>
    </div>

    <div class="slider-row">
      <div class="time-label">Temps : <span id="timeDisplay">—</span> s</div>
      <input id="timeSlider" type="range" min="0" max="0" value="0" step="1" style="flex:1">
      <label style="display:flex;align-items:center;gap:6px">Vitesse:
        <input id="speedRange" type="range" min="10" max="500" value="100" style="width:160px">
      </label>
      <button id="play" class="btn" style="width:80px">▶ Play</button>
    </div>

    <div style="margin-top:8px" class="small">Affichage : contours |u| + quiver (réduit) + trajectoires rouges + flèches de vitesse locales + étiquettes de vitesse.</div>
  </section>
</main>

<script>
  // DOM
  const runBtn = document.getElementById('run');
  const statusEl = document.getElementById('status');
  const nImageInput = document.getElementById('n_image');
  const gridNxInput = document.getElementById('grid_nx');
  const gridNyInput = document.getElementById('grid_ny');
  const TfinalInput = document.getElementById('Tfinal');
  const computeFieldCheckbox = document.getElementById('compute_field');

  const plotFieldDiv = document.getElementById('plotField');
  const plotParticlesDiv = document.getElementById('plotParticles');

  const timeSlider = document.getElementById('timeSlider');
  const timeDisplay = document.getElementById('timeDisplay');
  const playBtn = document.getElementById('play');
  const progressBar = document.getElementById('progressBar');
  const speedRange = document.getElementById('speedRange');

  let pyodide = null, pyReady = false;
  let simData = null, stored=null, playInterval=null;

  async function ensurePyodide(){
    if(pyReady) return;
    statusEl.textContent = 'Chargement Pyodide...';
    pyodide = await loadPyodide({indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.0/full/"});
    statusEl.textContent = 'Pyodide chargé — préparation de numpy...';
    try {
      await pyodide.loadPackage(['numpy']);
      statusEl.textContent = 'numpy chargé via loadPackage.';
    } catch (e) {
      console.warn('loadPackage numpy failed, fallback to micropip', e);
      try { await pyodide.loadPackage(['micropip']); } catch(err){}
      try {
        await pyodide.runPythonAsync(`
import micropip
await micropip.install("numpy")
`);
        statusEl.textContent = 'numpy installé via micropip.';
      } catch(err2){
        console.error('Impossible d\'installer numpy via micropip:', err2);
        statusEl.textContent = 'Erreur: impossible d\'installer numpy: ' + (err2.message || err2);
        throw err2;
      }
    }
    pyReady = true;
    statusEl.textContent = 'Pyodide & numpy prêts.';
  }

  async function fetchAndInjectSimulation(){
    statusEl.textContent = 'Récupération simulation.py ...';
    const r = await fetch('simulation.py', {cache:'no-store'});
    if(!r.ok){ statusEl.textContent = 'Erreur fetch simulation.py: HTTP ' + r.status; throw new Error('fetch error'); }
    const txt = await r.text();
    statusEl.textContent = 'Injection du code Python...';
    try {
      await pyodide.runPythonAsync(txt);
      statusEl.textContent = 'Code Python injecté.';
    } catch(err){
      console.error('Erreur lors de l\'injection/exécution de simulation.py', err);
      statusEl.textContent = 'Erreur exécution simulation.py: ' + (err.message || err);
      throw err;
    }
  }

  // Appel simulate (compute_field 'True'/'False' string because we call via runPythonAsync)
  async function callSim(n_image, grid_nx, grid_ny, Tfinal, compute_field){
    statusEl.textContent = 'Exécution simulate(...) (peut prendre du temps)...';
    progressBar.style.width = '2%';
    const dt = Tfinal / Math.max(1, (n_image - 1));
    const pyCall = `
import json
res = simulate(steps=None, dt=${dt}, n_image_local=${n_image}, grid_nx_field=${grid_nx}, grid_ny_field=${grid_ny}, grid_extent_local=5.0, compute_field=${compute_field})
json.dumps(res)
`;
    const jsonStr = await pyodide.runPythonAsync(pyCall);
    progressBar.style.width = '100%';
    return JSON.parse(jsonStr);
  }

  // builds the field plot (contours + quiver) for frame 0 and the particles plot (trails + markers)
  function initPlots(data){
    simData = data;
    const t = data.t;
    const n_image = data.n_image;
    const N = data.N;

    // FIELD: if present (Ux_fields and Uy_fields non-empty)
    const hasField = Array.isArray(data.Ux_fields) && data.Ux_fields.length>0 && data.Ux_fields[0].length>0;
    if(hasField){
      const grid_nx = data.grid_nx, grid_ny = data.grid_ny;
      // magnitude for first frame
      const Ux0 = data.Ux_fields[0];
      const Uy0 = data.Uy_fields[0];
      // compute magnitude and reshape
      const z0 = [];
      for(let j=0;j<grid_ny;j++){
        const row = [];
        for(let i=0;i<grid_nx;i++){
          const idx = j*grid_nx + i;
          const mag = Math.hypot(Ux0[idx], Uy0[idx]);
          row.push(mag);
        }
        z0.push(row);
      }
      const contour = {
        z: z0,
        x: data.grid_x,
        y: data.grid_y,
        type: 'contour',
        colorscale: 'Viridis',
        contours: { coloring: 'lines' },
        showscale: true,
        colorbar: { title: '|u|', thickness:20 }
      };

      // build quiver (sample every few grid points to avoid clutter)
      const stride = Math.max(1, Math.floor(data.grid_nx / 18));
      const qx = [], qy = [], quvx = [], quvy = [];
      for(let j=0;j<data.grid_ny;j+=stride){
        for(let i=0;i<data.grid_nx;i+=stride){
          const idx = j*data.grid_nx + i;
          qx.push(data.grid_x[i]);
          qy.push(data.grid_y[j]);
          quvx.push(Ux0[idx]);
          quvy.push(Uy0[idx]);
        }
      }
      // arrows as line segments (single trace made of many segments separated by null)
      const ax = [], ay = [];
      const head_x = [], head_y = [];
      const scale = 0.25 * Math.max(data.grid_x[1]-data.grid_x[0], data.grid_y[1]-data.grid_y[0]);
      for(let k=0;k<qx.length;k++){
        const x0 = qx[k], y0 = qy[k];
        const vx = quvx[k], vy = quvy[k];
        const x1 = x0 + scale * vx;
        const y1 = y0 + scale * vy;
        ax.push(x0); ax.push(x1); ax.push(null);
        ay.push(y0); ay.push(y1); ay.push(null);
        // small triangle/marker for head
        head_x.push(x1); head_y.push(y1);
      }
      const arrows = { x: ax, y: ay, mode: 'lines', line:{color:'rgba(40,40,90,0.9)', width:1.6}, hoverinfo:'none', showlegend:false };
      const heads = { x: head_x, y: head_y, mode: 'markers', marker:{size:6,symbol:'triangle-up',angle:0}, hoverinfo:'none', showlegend:false };

      Plotly.newPlot(plotFieldDiv, [contour, arrows, heads], { title: 'Champ |u| (contours) + quiver (échantillonné)', margin:{t:30}, xaxis:{title:'x'}, yaxis:{title:'y',scaleanchor:'x',scaleratio:1} }, {responsive:true});
    } else {
      // hide field if none
      plotFieldDiv.style.display = 'none';
    }

    // PARTICLES: create traces: N trail lines, then current positions (markers), then arrows for velocities, then text labels for speeds
    const traces = [];
    // initial trails empty
    for(let i=0;i<N;i++){
      traces.push({
        x: [], y: [], mode:'lines', line:{color:'red', width:2}, opacity:0.9, hoverinfo:'none', showlegend:false
      });
    }
    // current markers
    const frame0_qs = data.qs_hist[0];
    const xs = [], ys = [];
    for(let i=0;i<frame0_qs.length;i+=2){ xs.push(frame0_qs[i]); ys.push(frame0_qs[i+1]); }
    traces.push({ x: xs, y: ys, mode:'markers', marker:{size:8,color:'red'}, name:'particles', hoverinfo:'text', text: [] });

    // velocity arrows as lines (one trace)
    const frame0_u = data.u_selfs[0];
    const ax = [], ay = [], headx = [], heady = [];
    for(let i=0;i<frame0_qs.length;i+=2){
      const x0 = frame0_qs[i], y0 = frame0_qs[i+1];
      const vx = frame0_u[i], vy = frame0_u[i+1];
      const x1 = x0 + 0.6*vx, y1 = y0 + 0.6*vy;
      ax.push(x0); ax.push(x1); ax.push(null);
      ay.push(y0); ay.push(y1); ay.push(null);
      headx.push(x1); heady.push(y1);
    }
    traces.push({ x: ax, y: ay, mode:'lines', line:{color:'black', width:2}, hoverinfo:'none', showlegend:false });
    traces.push({ x: headx, y: heady, mode:'markers', marker:{size:6,symbol:'triangle-up'}, hoverinfo:'none', showlegend:false });

    // speed labels (text) as separate scatter trace
    const speedTexts = [];
    for(let i=0;i<frame0_qs.length;i+=2){
      const vx = frame0_u[i], vy = frame0_u[i+1];
      const speed = Math.hypot(vx,vy);
      speedTexts.push(speed.toFixed(3));
    }
    traces.push({ x: xs, y: ys, mode:'text', text: speedTexts, textposition:'top center', showlegend:false, hoverinfo:'none', textfont:{color:'black',size:10} });

    Plotly.newPlot(plotParticlesDiv, traces, { title:'Trajectoires & vitesses locales', margin:{t:30}, xaxis:{title:'x'}, yaxis:{title:'y',scaleanchor:'x',scaleratio:1} }, {responsive:true});

    // slider setup
    timeSlider.min = 0;
    timeSlider.max = Math.max(0, t.length - 1);
    timeSlider.value = 0;
    timeDisplay.textContent = t[0].toFixed(3);

    stored = { t, N };
  }

  // update frame: update trails (many traces), marker, velocity arrows, speed texts, and field (contours+quiver heads)
  function updateFrame(idx){
    if(!simData) return;
    const data = simData;
    const t = data.t;
    const N = data.N;

    // FIELD update
    const hasField = Array.isArray(data.Ux_fields) && data.Ux_fields.length>0 && data.Ux_fields[0].length>0;
    if(hasField){
      const grid_nx = data.grid_nx, grid_ny = data.grid_ny;
      const Ux = data.Ux_fields[idx], Uy = data.Uy_fields[idx];
      // magnitude z
      const z = [];
      for(let j=0;j<grid_ny;j++){
        const row = [];
        for(let i=0;i<grid_nx;i++){
          const id = j*grid_nx + i;
          row.push(Math.hypot(Ux[id], Uy[id]));
        }
        z.push(row);
      }
      Plotly.restyle(plotFieldDiv, {'z':[z]}, [0]); // update contour
      // quiver: sample
      const stride = Math.max(1, Math.floor(grid_nx / 18));
      const ax = [], ay = [], headx=[], heady=[];
      const scale = 0.25 * Math.max(data.grid_x[1]-data.grid_x[0], data.grid_y[1]-data.grid_y[0]);
      for(let j=0;j<grid_ny;j+=stride){
        for(let i=0;i<grid_nx;i+=stride){
          const id = j*grid_nx + i;
          const x0 = data.grid_x[i], y0 = data.grid_y[j];
          const x1 = x0 + scale * Ux[id], y1 = y0 + scale * Uy[id];
          ax.push(x0); ax.push(x1); ax.push(null);
          ay.push(y0); ay.push(y1); ay.push(null);
          headx.push(x1); heady.push(y1);
        }
      }
      Plotly.restyle(plotFieldDiv, {'x':[ax],'y':[ay]}, [1]); // arrows lines
      Plotly.restyle(plotFieldDiv, {'x':[headx],'y':[heady]}, [2]); // heads
    }

    // PARTICLES
    // build trails arrays for each particle up to idx
    const trailsX = [], trailsY = [];
    for(let p=0;p<N;p++){
      const xs = [], ys = [];
      for(let f=0; f<=idx; f++){
        const frame = data.qs_hist[f];
        xs.push(frame[2*p]);
        ys.push(frame[2*p+1]);
      }
      trailsX.push(xs);
      trailsY.push(ys);
    }
    // trace indices 0..N-1 are trails
    const trailIndices = Array.from({length:N}, (_,i)=>i);
    Plotly.restyle(plotParticlesDiv, {'x': [trailsX], 'y': [trailsY]}, trailIndices);

    // update current markers (trace index N)
    const frame_qs = data.qs_hist[idx];
    const xs_now = [], ys_now = [];
    for(let i=0;i<frame_qs.length;i+=2){ xs_now.push(frame_qs[i]); ys_now.push(frame_qs[i+1]); }
    Plotly.restyle(plotParticlesDiv, {'x':[xs_now], 'y':[ys_now]}, [N]);

    // update velocity arrows (trace N+1 = lines, N+2 = heads)
    const frame_u = data.u_selfs[idx];
    const ax = [], ay = [], hx = [], hy = [];
    for(let i=0;i<frame_qs.length;i+=2){
      const x0 = frame_qs[i], y0 = frame_qs[i+1];
      const vx = frame_u[i], vy = frame_u[i+1];
      const x1 = x0 + 0.6*vx, y1 = y0 + 0.6*vy;
      ax.push(x0); ax.push(x1); ax.push(null);
      ay.push(y0); ay.push(y1); ay.push(null);
      hx.push(x1); hy.push(y1);
    }
    Plotly.restyle(plotParticlesDiv, {'x':[ax],'y':[ay]}, [N+1]);
    Plotly.restyle(plotParticlesDiv, {'x':[hx], 'y':[hy]}, [N+2]);

    // update speed text (trace N+3)
    const speedTexts = [];
    for(let i=0;i<frame_qs.length;i+=2){
      const vx = frame_u[i], vy = frame_u[i+1];
      speedTexts.push(Math.hypot(vx,vy).toFixed(3));
    }
    Plotly.restyle(plotParticlesDiv, {'x':[xs_now], 'y':[ys_now], 'text':[speedTexts]}, [N+3]);

    // slider display
    timeSlider.value = idx;
    timeDisplay.textContent = t[idx].toFixed(3);
  }

  // slider / play handlers
  timeSlider.addEventListener('input', (e)=> updateFrame(parseInt(e.target.value)));
  let playSpeedMs = 100;
  speedRange.addEventListener('input', ()=> {
    const v = parseInt(speedRange.value);
    // map 10..500 to 1000..10 ms: faster when slider high
    playSpeedMs = Math.max(10, Math.round(1100 - 2 * v));
  });

  playBtn.addEventListener('click', ()=>{
    if(!simData) return;
    if(playInterval){
      clearInterval(playInterval);
      playInterval = null;
      playBtn.textContent = '▶ Play';
      return;
    }
    playBtn.textContent = '⏸ Pause';
    const maxIdx = simData.t.length - 1;
    playInterval = setInterval(()=>{
      let idx = parseInt(timeSlider.value);
      idx = (idx < maxIdx) ? idx + 1 : 0;
      updateFrame(idx);
    }, playSpeedMs);
  });

  // Run sequence
  runBtn.addEventListener('click', async ()=>{
    runBtn.disabled = true;
    progressBar.style.width = '2%';
    try {
      const n_image = parseInt(nImageInput.value) || 30;
      const grid_nx = parseInt(gridNxInput.value) || 32;
      const grid_ny = parseInt(gridNyInput.value) || 32;
      const Tfinal = parseFloat(TfinalInput.value) || 10.0;
      const compute_field = computeFieldCheckbox.checked ? 'True' : 'False';

      await ensurePyodide();
      await fetchAndInjectSimulation();
      statusEl.textContent = 'Calcul en cours (Python)...';
      const data = await callSim(n_image, grid_nx, grid_ny, Tfinal, compute_field);
      statusEl.textContent = 'Simulation calculée en Python — rendu...';
      initPlots(data);
      updateFrame(0);
      statusEl.textContent = 'Terminé — utilisez le slider ou Play.';
      progressBar.style.width = '100%';
    } catch(e){
      console.error(e);
      statusEl.textContent = 'Erreur : ' + (e.message || e);
      progressBar.style.width = '0%';
    } finally {
      runBtn.disabled = false;
    }
  });
</script>
</body>
</html>
