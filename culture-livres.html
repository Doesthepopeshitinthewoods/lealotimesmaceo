<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Culture — Livres</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Merriweather:wght@300;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --maxw:1100px;
      --bg:#fafaf9;
      --card:#ffffff;
      --muted:#6b7280;
      --accent:#8b0000;
      --accent-strong:#6b0000;
      --text:#0f172a;
      --glass: rgba(255,255,255,0.6);
      --radius:12px;
      --shadow: 0 6px 18px rgba(15,23,42,0.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: linear-gradient(180deg, #fff 0%, var(--bg) 100%);
      color:var(--text);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      line-height:1.6;
      padding:28px 18px;
      display:flex;
      justify-content:center;
    }

    .container{width:100%;max-width:var(--maxw);}

    header{
      background: linear-gradient(90deg,var(--accent-strong),var(--accent));
      color:#fff;
      border-radius:12px;
      padding:18px;
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    header h1{margin:0;font-family:Merriweather,serif;font-weight:700;font-size:20px}
    header nav a{color:rgba(255,255,255,0.95);text-decoration:none;margin-left:14px;font-weight:600;font-size:14px;opacity:0.95}
    header nav a:hover{text-decoration:underline;opacity:1}

    .layout{
      margin-top:22px;
      display:grid;
      grid-template-columns: 1fr 380px;
      gap:22px;
      align-items:start;
    }

    /* List column */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.6), var(--card));
      border-radius:var(--radius);
      padding:18px;
      box-shadow: var(--shadow);
      min-height:200px;
    }
    .panel h2{margin:0 0 12px;font-family:Merriweather,serif}
    .grid-list{
      display:grid;
      grid-template-columns: repeat(2,1fr);
      gap:12px;
    }
    @media (max-width:900px){ .layout{ grid-template-columns: 1fr; } .grid-list{ grid-template-columns: 1fr; } }

    .card{
      background:var(--card);
      border-radius:10px;
      padding:12px;
      border:1px solid rgba(15,23,42,0.04);
      box-shadow: 0 4px 10px rgba(15,23,42,0.03);
    }
    .card h3{margin:0 0 6px;font-size:16px}
    .meta{font-size:13px;color:var(--muted);margin-bottom:8px}
    .content{font-size:14px;color:var(--text);white-space:pre-wrap}
    .badge{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px;background:#fffbeb;color:#b45309;margin-left:8px}

    .card .actions{display:flex;gap:8px;margin-top:10px}
    .btn{
      font-size:13px;padding:8px 10px;border-radius:8px;border:1px solid rgba(15,23,42,0.06);cursor:pointer;background:transparent;
    }
    .btn.danger{border-color:#fee2e2;color:#7f1d1d}
    .btn.ghost{background:transparent}

    /* Form column */
    aside.panel{
      position:sticky; top:28px;
      display:flex;flex-direction:column;gap:12px;
    }
    form{display:flex;flex-direction:column;gap:10px}
    label{font-size:13px;color:var(--muted);display:flex;justify-content:space-between;align-items:center}
    input,textarea,select{
      padding:10px;border-radius:8px;border:1px solid rgba(15,23,42,0.06);font-size:14px;
      outline:none;background:transparent;
    }
    textarea{min-height:110px;resize:vertical}
    .primary{
      background:var(--accent);color:#fff;border:none;padding:12px 14px;border-radius:10px;font-weight:600;cursor:pointer;
      box-shadow: 0 6px 16px rgba(139,0,0,0.12);
    }
    .muted-note{font-size:13px;color:var(--muted);}

    /* Preview */
    .preview{
      border-radius:10px;padding:12px;background:linear-gradient(180deg,#fff,#fbfbfd);border:1px solid rgba(15,23,42,0.03);
      margin-top:6px;font-size:14px;
    }

    footer{margin-top:20px;text-align:center;color:var(--muted);font-size:13px}
    .result{font-size:14px;color:var(--muted);min-height:20px}

    /* small screens: tighten margins */
    @media (max-width:520px){
      body{padding:18px}
      header{padding:14px}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Blog de l'intranquilité — Livres</h1>
      <nav aria-label="Navigation principale">
        <a href="index.html">Accueil</a>
        <a href="culture-films.html">Films</a>
        <a href="culture-musiques.html">Musiques</a>
      </nav>
    </header>

    <div class="layout" role="main">
      <!-- LIST -->
      <section class="panel" aria-labelledby="recent-title">
        <h2 id="recent-title">Propositions récentes</h2>
        <p class="muted-note">Les propositions locales en attente sont affichées en premier, suivies des propositions publiées.</p>

        <div id="proposals" class="grid-list" aria-live="polite">
          <!-- cards injected here -->
        </div>

        <div style="margin-top:12px" class="muted-note">
          <strong>Astuce :</strong> Si tu n’as pas de serveur disponible, les propositions sont conservées dans ton navigateur (localStorage).
        </div>
      </section>

      <!-- FORM -->
      <aside class="panel" aria-labelledby="form-title">
        <h2 id="form-title">Proposer un livre</h2>

        <form id="proposal-form" autocomplete="off" novalidate>
          <label>Pseudo
            <input name="pseudo" required placeholder="Ton pseudo">
          </label>

          <label>Titre
            <input name="title" required placeholder="Titre du livre">
          </label>

          <label>Auteur (optionnel)
            <input name="author" placeholder="Nom de l'auteur">
          </label>

          <label>Pourquoi ce livre ?
            <textarea name="content" required placeholder="Écris une courte recommandation..."></textarea>
          </label>

          <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
            <button class="primary" type="submit">Envoyer la proposition</button>
            <div class="result" id="result" aria-live="polite"></div>
          </div>

          <div style="margin-top:8px">
            <div class="muted-note">Prévisualisation :</div>
            <div id="preview" class="preview"><em>Aucune saisie</em></div>
          </div>
        </form>

        <div style="margin-top:8px" class="muted-note">Serveur configuré : <strong id="worker-url-display"></strong></div>
      </aside>
    </div>

    <footer>
      © <span id="year"></span> — Blog personnel
    </footer>
  </div>

  <!-- dépendances -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>

  <script>
  /* CONFIG */
  const WORKER_URL = "https://steep-dawn-b94d.ettae634.workers.dev";
  const LOCAL_KEY = 'livres_pending_v1';

  // éléments DOM
  const $ = s => document.querySelector(s);
  const proposalsEl = $('#proposals');
  const previewEl = $('#preview');
  const resultEl = $('#result');
  $('#worker-url-display').textContent = WORKER_URL;

  // utils
  function escapeHtml(s){ return String(s ?? '').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;') }
  function sanitizeHtml(html){ return window.DOMPurify && DOMPurify.sanitize ? DOMPurify.sanitize(html) : escapeHtml(html); }
  function mdToHtml(md){ try{ return sanitizeHtml(marked.parse(md||'')); }catch(e){ return sanitizeHtml(escapeHtml(md||'')); } }

  // storage pending
  let pending = loadPending();

  function loadPending(){
    try{
      const raw = localStorage.getItem(LOCAL_KEY);
      if(!raw) return [];
      return JSON.parse(raw);
    }catch(e){
      console.warn('localStorage parse error', e);
      return [];
    }
  }
  function savePending(){ try{ localStorage.setItem(LOCAL_KEY, JSON.stringify(pending)); }catch(e){ console.warn('save pending failed', e); } }
  function addPending(item){ pending.unshift(item); savePending(); }
  function removePending(tempId){ const i = pending.findIndex(p=>p._tempId===tempId); if(i>-1){ pending.splice(i,1); savePending(); return true } return false }

  // initial render
  renderAll();

  /* ========== FORM behavior & preview ========== */
  const form = $('#proposal-form');
  const formInputs = form.querySelectorAll('input,textarea');

  // live preview
  form.addEventListener('input', ()=> {
    const data = Object.fromEntries(new FormData(form).entries());
    const title = data.title || 'Titre du livre';
    const pseudo = data.pseudo || 'Anonyme';
    const author = data.author || '';
    const content = data.content || '';
    const html = `
      <strong>${escapeHtml(title)}</strong>
      <div class="meta">Par ${escapeHtml(pseudo)}${author ? ' — Auteur : '+escapeHtml(author) : ''}</div>
      <div class="content">${mdToHtml(content)}</div>
    `;
    previewEl.innerHTML = html;
  });

  form.addEventListener('submit', async e => {
    e.preventDefault();
    resultEl.textContent = 'Envoi…';

    const data = Object.fromEntries(new FormData(form).entries());
    if(!data.pseudo || !data.title || !data.content){
      resultEl.textContent = 'Remplis tous les champs requis.';
      return;
    }

    // optimiste: ajouter en pending local
    const temp = Object.assign({}, data, {_tempId: 't'+Date.now()+Math.random().toString(36).slice(2,6), createdAt: Date.now()});
    addPending(temp);
    renderAll();
    form.reset();
    previewEl.innerHTML = '<em>Aucune saisie</em>';
    resultEl.textContent = 'Proposition enregistrée localement…';

    // tenter l'envoi au serveur
    try{
      const r = await fetch(WORKER_URL, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(data)
      });
      const j = await r.json().catch(()=>({ success: r.ok }));
      if(j && j.success){
        resultEl.textContent = '✔ Proposition envoyée au serveur';
        // si le serveur renvoie l'item, on peut supprimer le pending correspondant
        if(j.item){
          // heuristique match
          const snippet = (j.item.content||'').trim().slice(0,120);
          const idx = pending.findIndex(p => p.title===j.item.title && p.pseudo===j.item.pseudo && (p.content||'').trim().slice(0,120)===snippet);
          if(idx>-1){ pending.splice(idx,1); savePending(); }
        }
        // recharger la liste depuis le serveur (tentative)
        await loadAndRenderServer();
        renderAll();
      } else {
        resultEl.textContent = 'Erreur serveur : ' + (j && j.error ? j.error : 'inconnue');
      }
    }catch(err){
      resultEl.textContent = 'Erreur réseau — proposition conservée localement';
      console.warn(err);
    }
  });

  /* ========== Rendering functions ========== */

  function cardHtml(obj, opts = {}) {
    // opts.pending true/false ; obj.contentHtml may exist
    const title = escapeHtml(obj.title || 'Sans titre');
    const pseudo = escapeHtml(obj.pseudo || 'Anonyme');
    const author = obj.author ? escapeHtml(obj.author) : '';
    const date = obj.date ? escapeHtml(obj.date) : (obj.createdAt ? new Date(obj.createdAt).toLocaleString() : '');
    const contentHtml = obj.contentHtml ? sanitizeHtml(obj.contentHtml) : mdToHtml(obj.content || '');
    const badge = opts.pending ? '<span class="badge">En attente</span>' : '';
    const dataAttr = opts.pending ? `data-temp="${escapeHtml(obj._tempId)}"` : (obj.path ? `data-path="${escapeHtml(obj.path)}"` : '');
    const deleteBtn = opts.pending
      ? `<button class="btn danger pending-delete" data-temp="${escapeHtml(obj._tempId)}" title="Supprimer localement">Supprimer</button>`
      : (obj.path ? `<button class="btn ghost server-delete" data-path="${escapeHtml(obj.path)}" title="Supprimer côté serveur">Supprimer</button>` : '');

    return `
      <article class="card" ${dataAttr}>
        <h3>${title} ${badge}</h3>
        <div class="meta">Par <strong>${pseudo}</strong>${author ? ' — Auteur : '+author : ''}${date ? ' — '+date : ''}</div>
        <div class="content">${contentHtml}</div>
        <div class="actions">${deleteBtn}</div>
      </article>
    `;
  }

  // render both pending + server items (serverItems can be empty)
  let serverItemsCache = []; // stocked pour suppression côté serveur
  function renderAll(){
    // merge pending (first) + server items (after), avoid duplicates by simple heuristic: title+pseudo+snippet
    const serverMap = serverItemsCache.map(si => ({
      title: si.title, pseudo: si.pseudo, snippet: (si.contentHtml ? stripHtml(si.contentHtml) : (si.content||'')).slice(0,120)
    }));

    // pending items not present in server
    const pendingHtml = pending
      .filter(p => {
        const pSnippet = (p.content||'').trim().slice(0,120);
        return !serverMap.some(sm => sm.title===p.title && sm.pseudo===p.pseudo && sm.snippet===pSnippet);
      })
      .map(p => cardHtml(p, {pending:true}))
      .join('');

    const serverHtml = serverItemsCache.map(si => cardHtml(si, {pending:false})).join('');

    proposalsEl.innerHTML = (pendingHtml + serverHtml) || '<div class="muted-note">Aucune proposition pour le moment.</div>';
    document.getElementById('year').textContent = new Date().getFullYear();
  }

  function stripHtml(html){ const tmp = document.createElement('div'); tmp.innerHTML = html || ''; return tmp.textContent || tmp.innerText || ''; }

  /* ========== FETCH server content (index + md) ========= */
  async function fetchIndexNoCache(){
    const url = WORKER_URL + '/index?t=' + Date.now();
    const r = await fetch(url, { cache: 'no-store' });
    if(!r.ok) throw new Error('status ' + r.status);
    return await r.json();
  }
  async function fetchMarkdownNoCache(path){
    const p = (path || '').replace(/^\/+/, '');
    const url = WORKER_URL + '/md?path=' + encodeURIComponent(p) + '&t=' + Date.now();
    const r = await fetch(url, { cache: 'no-store' });
    if(!r.ok) throw new Error('md status ' + r.status + ' ' + p);
    return await r.text();
  }

  async function loadAndRenderServer(){
    try{
      const index = await fetchIndexNoCache();
      const BASE_PATH = 'lealotimesmaceo/content/livres/';
      const items = (index||[]).filter(i => i.section==='livres' || (i.path && i.path.startsWith(BASE_PATH)));
      const serverItems = await Promise.all(items.map(async i => {
        try{
          const md = await fetchMarkdownNoCache(i.path);
          const body = md.replace(/^---[\\s\\S]*?---/, ''); // retire frontmatter si présent
          return { title: i.title, pseudo: i.pseudo, author: i.author || '', contentHtml: marked.parse(body), path: i.path, date: i.date || '' };
        }catch(e){
          return { title: i.title, pseudo: i.pseudo, contentHtml: '<div class="meta">Erreur lecture contenu</div>', path: i.path };
        }
      }));
      serverItemsCache = serverItems;
      renderAll();
    }catch(e){
      console.warn('load server failed', e);
      // conserve ce qu'on a (pending)
      serverItemsCache = [];
      renderAll();
    }
  }

  // initial server load (non-blocking)
  loadAndRenderServer();

  /* ========== Polling backoff similar to original ========= */
  let pollHandle = null, pollAttempts = 0;
  const POLL_MAX = 8;
  function pollOnce(){
    pollAttempts++;
    loadAndRenderServer().then(()=>{
      if(pending.length===0 || pollAttempts>=POLL_MAX) clearPoll();
      else { const delay = Math.min(1000 * Math.pow(2, pollAttempts-1), 30000); pollHandle = setTimeout(pollOnce, delay); }
    }).catch(()=>{ const delay = Math.min(1000 * Math.pow(2, pollAttempts-1), 30000); pollHandle = setTimeout(pollOnce, delay); });
  }
  function ensurePolling(){ if(pollHandle) return; pollAttempts=0; pollOnce(); }
  function clearPoll(){ if(pollHandle) clearTimeout(pollHandle); pollHandle=null; pollAttempts=0; }

  /* ========== Delete handlers (event delegation) ========= */
  proposalsEl.addEventListener('click', async (ev) => {
    const btn = ev.target.closest('button');
    if(!btn) return;

    // supprimer local
    if(btn.classList.contains('pending-delete')){
      const temp = btn.dataset.temp;
      if(!confirm('Supprimer cette proposition locale ?')) return;
      if(removePending(temp)){
        resultEl.textContent = 'Proposition locale supprimée';
        renderAll();
      } else resultEl.textContent = 'Introuvable';
      return;
    }

    // supprimer côté serveur
    if(btn.classList.contains('server-delete')){
      const path = btn.dataset.path;
      if(!path){ resultEl.textContent = 'Impossible : pas de chemin connu pour cette proposition.'; return; }
      if(!confirm('Confirmer suppression sur le serveur ? Cette action est irréversible sur le serveur.')) return;

      try{
        btn.disabled = true;
        resultEl.textContent = 'Suppression…';
        const r = await fetch(WORKER_URL + '/delete', {
          method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ path })
        });
        let j = {};
        try{ j = await r.json(); }catch(e){ j = { success: r.ok } }

        if(r.ok && j.success){
          resultEl.textContent = '✔ Supprimé sur le serveur';
          await loadAndRenderServer();
        } else {
          resultEl.textContent = 'Erreur suppression: ' + (j.error || r.status || 'inconnue');
          btn.disabled = false;
        }
      }catch(err){
        resultEl.textContent = 'Erreur réseau';
        btn.disabled = false;
        console.warn(err);
      }
    }
  });

  // auto-refresh every 5 minutes
  setInterval(loadAndRenderServer, 5*60*1000);

  // start background polling if we have pending
  if(pending.length) ensurePolling();
  </script>
</body>
</html>
