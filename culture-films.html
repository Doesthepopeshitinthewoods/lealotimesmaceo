<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Culture — Films</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Merriweather:wght@300;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --maxw:760px;
      --bg:#fbfcfe;
      --card:#ffffff;
      --muted:#6b7280;
      --text:#0f172a;
      --accent:#8b0000;
      --accent-600:#7a0000;
      --glass:rgba(15,23,42,0.04);
      --radius:12px;
      --gap:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;
      background:linear-gradient(180deg,var(--bg),#eef2f6);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      line-height:1.6;
    }
    header{
      background:linear-gradient(90deg,var(--accent),var(--accent-600));
      color:#fff;
      border-bottom:1px solid rgba(0,0,0,0.06);
    }
    .wrap{
      max-width:var(--maxw);
      margin:0 auto;
      padding:18px 20px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    h1.site-title{margin:0;font-family:Merriweather,serif;font-size:20px;font-weight:700}
    nav{display:flex;gap:12px;align-items:center}
    nav a{color:rgba(255,255,255,0.92);text-decoration:none;font-size:14px}
    nav a:hover{text-decoration:underline}

    main{max-width:var(--maxw);margin:36px auto;padding:0 20px}
    .grid{display:grid;grid-template-columns:1fr 360px;gap:28px}
    @media (max-width:980px){ .grid{grid-template-columns:1fr} }

    .card{background:var(--card);border-radius:var(--radius);box-shadow:0 8px 30px rgba(16,24,40,0.06);padding:18px;display:flex;gap:18px;align-items:flex-start}
    .cover{width:120px;height:160px;border-radius:8px;background:linear-gradient(135deg,#fff,#f3f7ff);display:flex;align-items:center;justify-content:center;font-weight:700;color:#0b1220;padding:10px;text-align:center}
    .meta{color:var(--muted);font-size:13px;margin:6px 0}
    h2.item-title{margin:0;font-size:20px}
    .description{margin-top:8px;color:#111827}

    .panel{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 6px 20px rgba(16,24,40,0.04)}
    form{display:flex;flex-direction:column;gap:10px}
    input,textarea,select{width:100%;padding:10px;border:1px solid #e6e9ef;border-radius:8px;font-size:14px}
    button.primary{padding:10px 14px;background:var(--accent);color:#fff;border:none;border-radius:8px;cursor:pointer}
    .muted{color:var(--muted);font-size:13px}

    #proposals-list article{border:1px solid #f1f5f9;padding:14px;border-radius:10px;margin-bottom:12px;background:linear-gradient(180deg,#fff,#fbfdff)}
    .badge{display:inline-block;background:var(--glass);padding:6px 8px;border-radius:999px;font-size:12px}
    .pending-badge{font-size:12px;color:#9ca3af;margin-left:8px}
    .actions{margin-top:10px}
    .delete-btn{background:transparent;border:1px solid #e5e7eb;color:var(--text);padding:6px 10px;border-radius:8px;cursor:pointer}
    .delete-btn:disabled{opacity:0.6;cursor:not-allowed}

    footer.site-footer{max-width:var(--maxw);margin:48px auto 30px;padding:0 20px;color:var(--muted);font-size:13px}
    pre.debug{display:none}

    @media print{ body{background:#fff} header,footer.site-footer{display:none} .card{box-shadow:none;border-radius:0} }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1 class="site-title">Blog de l'intranquilité</h1>
      <nav aria-label="Navigation principale">
        <a href="index.html">Accueil</a>
        <a href="culture-films.html">Films</a>
        <a href="culture-livres.html">Livres</a>
        <a href="culture-musiques.html">Musiques</a>
        <a href="projets-libres-pensees.html">Projets</a>
      </nav>
    </div>
  </header>

  <main>
    <div class="grid">
      <section>
        <article class="card simple-item" aria-labelledby="simple-title">
          <div style="padding:12px">
            <h2 id="simple-title" class="item-title">Fenêtre sur cour</h2>
            <p class="meta"><span id="simple-pseudo">Pseudo : Cinephile</span> &nbsp; • &nbsp; <span id="simple-author">Réalisateur : —</span></p>

            <h3 style="font-size:14px;margin-top:10px;color:var(--muted)">Description</h3>
            <p id="simple-description" class="description">description : exemple d'un film marquant — texte d'exemple.</p>

            <div style="margin-top:12px"><span class="badge">fiche film</span></div>
          </div>
        </article>

        <h2 style="margin-top:26px">Recommendations récentes <small style="color:var(--muted);font-size:13px"> (en attente d'ajout)</small></h2>
        <div id="proposals-list" class="panel">Chargement…</div>
      </section>

      <aside>
        <div class="panel">
          <h3 style="margin:0 0 8px 0">Proposer un film</h3>
          <form id="proposal-form">
            <input type="hidden" name="section" value="films">
            <input name="pseudo" placeholder="Pseudo" required>
            <input name="title" placeholder="Titre du film" required>
            <input name="author" placeholder="Réalisateur / année (optionnel)">
            <textarea name="content" rows="5" placeholder="Pourquoi ce film ? (commentaire en Markdown possible)" required></textarea>
            <button class="primary">Envoyer</button>
          </form>

          <p id="result" class="muted" style="margin-top:10px"></p>
        </div>
      </aside>
    </div>

    <pre id="debug" class="debug"></pre>
  </main>

  <footer class="site-footer">
    © <span id="year"></span> — Blog personnel
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>

  <script>
  // ---------- CONFIG ----------
  const WORKER_URL = "https://steep-dawn-b94d.ettae634.workers.dev";
  const LOCAL_KEY = 'films_pending_v1';
  const BASE_PATH = 'lealotimesmaceo/content/films/';

  // If true, we WILL NOT overwrite the featured "fenêtre sur cour" block automatically.
  // This ensures the featured film remains as authored in the HTML until you deliberately change it.
  const LOCK_FEATURED = true;

  // ---------- HELPERS ----------
  const $ = s => document.querySelector(s);
  function escapeHtml(s){ return String(s ?? '').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;') }
  function debug(t){ const el = $('#debug'); if(!el) return; el.style.display = t ? 'block' : 'none'; el.textContent = t || '' }

  // ---------- PENDING STORAGE ----------
  let pending = loadPendingFromStorage();

  function loadPendingFromStorage(){
    try{ const raw = localStorage.getItem(LOCAL_KEY); if(!raw) return []; return JSON.parse(raw); }catch(e){ console.error('failed parse pending', e); return []; }
  }
  function savePendingToStorage(){ try{ localStorage.setItem(LOCAL_KEY, JSON.stringify(pending)); }catch(e){ console.warn('localStorage full?'); } }
  function addPending(item){ pending.unshift(item); savePendingToStorage(); }
  function removePendingByTempId(tempId){ const idx = pending.findIndex(p => p._tempId === tempId); if(idx !== -1){ pending.splice(idx,1); savePendingToStorage(); return true;} return false; }
  function removePendingMatchedByServerItem(serverItem){
    const sContent = (serverItem.content||'').trim().slice(0,120);
    const idx = pending.findIndex(p => p.title === serverItem.title && p.pseudo === serverItem.pseudo && (p.content||'').trim().slice(0,120) === sContent);
    if(idx!==-1){ pending.splice(idx,1); savePendingToStorage(); return true; }
    return false;
  }

  // ---------- SANITIZE / MARKDOWN ----------
  function sanitizeHtml(html){ if(window.DOMPurify && typeof DOMPurify.sanitize === 'function') return DOMPurify.sanitize(html); return escapeHtml(html); }
  function renderMarkdown(md){ try{ return sanitizeHtml(marked.parse(md || '')); }catch(e){ return sanitizeHtml(escapeHtml(md || '')); } }

  // ---------- BUILD ARTICLE (used for pending items) ----------
  function buildArticleHtml(obj, opts = {}){
    const isPending = !!opts.pending;
    const badge = isPending ? '<span class="pending-badge">(en attente)</span>' : '';
    const contentHtml = obj.contentHtml ? sanitizeHtml(obj.contentHtml) : renderMarkdown(obj.content || '');
    const authorLine = obj.author ? '<div class="meta">Réalisateur : '+escapeHtml(obj.author)+'</div>' : '';

    let actionsHtml = '';
    if(isPending && obj._tempId){ actionsHtml = '<div class="actions"><button class="delete-btn pending-delete" data-temp="'+escapeHtml(obj._tempId)+'">Supprimer</button></div>'; }
    if(!isPending && obj.path){ actionsHtml = '<div class="actions"><button class="delete-btn server-delete" data-path="'+escapeHtml(obj.path)+'">Supprimer</button></div>'; }

    const articleAttrs = (obj._tempId ? 'data-temp="'+escapeHtml(obj._tempId)+'"' : '') + (obj.path ? ' data-path="'+escapeHtml(obj.path)+'"' : '');

    return '<article '+articleAttrs+'>'
      +'<h3>'+escapeHtml(obj.title || 'Sans titre')+' '+badge+'</h3>'
      +'<div class="meta">Par '+escapeHtml(obj.pseudo || 'Anonyme')+'</div>'
      +authorLine
      +'<div class="content">'+contentHtml+'</div>'
      +actionsHtml
      +'</article>';
  }

  function stripHtml(html){ const tmp = document.createElement('div'); tmp.innerHTML = html || ''; return tmp.textContent || tmp.innerText || ''; }

  // ---------- MARKDOWN / FILENAME GENERATION ----------
  function slugify(s){
    return String(s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'').slice(0,70);
  }

  function generateMarkdown(item){
    const now = new Date().toISOString();
    const frontmatter = [
      '---',
      `title: "${(item.title||'').replace(/"/g,'\\"')}"`,
      `pseudo: "${(item.pseudo||'').replace(/"/g,'\\"')}"`,
      item.author ? `author: "${(item.author||'').replace(/"/g,'\\"')}"` : '',
      `date: "${now}"`,
      '---',
      ''
    ].filter(Boolean).join('\n');

    const body = (item.content || '').trim();
    return frontmatter + '\n' + body + '\n';
  }

  function generateFilename(item){
    const base = slugify(item.title || (item.pseudo ? item.pseudo + '-film' : 'proposition'));
    const uniq = Date.now().toString(36).slice(-6);
    return `${base}-${uniq}.md`;
  }

  // ---------- SYNC PENDING ----------
  async function syncPending(){
    if(!pending || pending.length === 0) return;
    const toTry = pending.slice();
    for(const p of toTry){
      const md = generateMarkdown(p);
      const filename = p.filename || generateFilename(p);
      const payload = { path: BASE_PATH + filename, content: md, title: p.title, pseudo: p.pseudo, author: p.author || '' };
      try{
        const r = await fetch(WORKER_URL + '/create', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(payload)
        });
        let j = {};
        try{ j = await r.json(); }catch(e){ j = { success: r.ok }; }
        if(r.ok && j.success){
          if(j.item){
            removePendingMatchedByServerItem(j.item);
          } else {
            removePendingMatchedByServerItem({ title: p.title, pseudo: p.pseudo, content: stripHtml(renderMarkdown(p.content || '')) });
          }
        } else {
          console.warn('syncPending: server error for', p.title, j.error || r.status);
        }
      }catch(err){
        console.warn('syncPending network error', err);
        debug(String(err));
        return;
      }
    }
  }

  // ---------- RENDER PENDING (Recommendations récentes) ----------
  function renderPendingList(){
    // show only pending items (new "Recommendations récentes")
    if(!pending || pending.length === 0){
      $('#proposals-list').innerHTML = '<div class="muted">Aucune recommendation en attente.</div>';
      return;
    }
    const html = pending.map(p => buildArticleHtml(p, { pending: true })).join('');
    $('#proposals-list').innerHTML = html;
  }

  // ---------- FETCH FUNCTIONS ----------
  async function fetchIndexNoCache(){ const url = WORKER_URL + '/index?t=' + Date.now(); const r = await fetch(url, { cache: 'no-store' }); if(!r.ok) throw new Error('status ' + r.status); return await r.json(); }
  async function fetchMarkdownNoCache(path){ let p = path || ''; while(p.charAt(0) === '/') p = p.slice(1); const url = WORKER_URL + '/md?path=' + encodeURIComponent(p) + '&t=' + Date.now(); const r = await fetch(url, { cache: 'no-store' }); if(!r.ok) throw new Error('md status ' + r.status + ' ' + p); return await r.text(); }

  // ---------- LOAD & RENDER ----------
  async function loadAndRenderNow(forceServerOnly = false){
    try{
      const index = await fetchIndexNoCache();
      const items = (index || []).filter(i => i.section === 'films' || (i.path && i.path.startsWith(BASE_PATH)));

      const serverItems = await Promise.all(items.map(async i => {
        try{
          let md = await fetchMarkdownNoCache(i.path);
          md = md.replace(/^---[\s\S]*?---\s*/, '');
          const body = md;
          return { title: i.title, pseudo: i.pseudo, author: i.author || '', contentHtml: marked.parse(body), path: i.path };
        }catch(e){ return { title: i.title, pseudo: i.pseudo, contentHtml: '<div class="meta">Erreur lecture contenu</div>', path: i.path }; }
      }));

      // remove pending items that appear on server
      for(const si of serverItems){ removePendingMatchedByServerItem({ title: si.title, pseudo: si.pseudo, content: stripHtml(si.contentHtml) }); }

      // render pending (recommendations) only
      renderPendingList();

      // update featured ONLY if not locked and server has items
      if(!LOCK_FEATURED){
        if(serverItems && serverItems.length){
          renderFeaturedItem({ title: serverItems[0].title, pseudo: serverItems[0].pseudo, author: serverItems[0].author || '', contentHtml: serverItems[0].contentHtml });
        } else if(pending && pending.length){
          const p = pending[0];
          renderFeaturedItem({ title: p.title, pseudo: p.pseudo, author: p.author || '', content: renderMarkdown(p.content) });
        }
      }
    }catch(e){
      console.warn('loadAndRenderNow failed', e);
      renderPendingList();
      debug(String(e));
    }
  }

  // ---------- POLLING (backoff) with syncPending ----------
  let pollHandle = null; let pollAttempts = 0; const POLL_MAX_ATTEMPTS = 8;
  function pollOnce(){
    pollAttempts++;
    syncPending().then(()=> loadAndRenderNow() ).then(()=> {
      if(pending.length === 0 || pollAttempts >= POLL_MAX_ATTEMPTS){ clearPoll(); } else { const delay = Math.min(1000 * Math.pow(2, pollAttempts-1), 30000); pollHandle = setTimeout(pollOnce, delay); }
    }).catch(()=>{ const delay = Math.min(1000 * Math.pow(2, pollAttempts-1), 30000); pollHandle = setTimeout(pollOnce, delay); });
  }
  function ensurePolling(){ if(pollHandle) return; pollAttempts = 0; pollOnce(); }
  function clearPoll(){ if(pollHandle) clearTimeout(pollHandle); pollHandle = null; pollAttempts = 0; }

  // ---------- FORM SUBMIT (add to pending immediately, then try to send) ----------
  document.getElementById('proposal-form').onsubmit = async e => {
    e.preventDefault();
    $('#result').textContent = 'Envoi…';

    const data = Object.fromEntries(new FormData(e.target).entries());
    if(!data.title || !data.content || !data.pseudo){ $('#result').textContent = 'Remplis tous les champs.'; return; }

    // Prepare item & add to pending immediately so it appears in "Recommendations récentes"
    const item = { title: data.title, pseudo: data.pseudo, author: data.author || '', content: data.content };
    const temp = Object.assign({}, item, { _tempId: 't'+Date.now()+Math.random().toString(36).slice(2,6), createdAt: Date.now(), filename: generateFilename(item) });
    addPending(temp);
    renderPendingList(); // update UI instantly
    ensurePolling(); // make sure sync will run

    // Then attempt to save on server (create endpoint)
    const md = generateMarkdown(item);
    const payload = { path: BASE_PATH + temp.filename, content: md, title: item.title, pseudo: item.pseudo, author: item.author };

    try{
      const r = await fetch(WORKER_URL + '/create', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      });
      let j = {};
      try{ j = await r.json(); }catch(e){ j = { success: r.ok }; }

      if(r.ok && j.success){
        $('#result').textContent = '✔ Proposition enregistrée sur le serveur';
        if(j.item) removePendingMatchedByServerItem(j.item);
        // refresh to reflect server state
        setTimeout(()=>loadAndRenderNow(true), 300);
      } else {
        $('#result').textContent = 'Proposition sauvegardée localement (erreur serveur)';
      }
    }catch(err){
      $('#result').textContent = 'Hors-ligne : proposition sauvegardée localement (en attente)';
      debug(String(err));
    } finally {
      e.target.reset();
    }
  };

  // ---------- DELETE HANDLERS ----------
  document.getElementById('proposals-list').addEventListener('click', async (e) => {
    const btn = e.target.closest('button.delete-btn'); if(!btn) return;

    if(btn.classList.contains('pending-delete')){
      const temp = btn.dataset.temp; if(!confirm('Supprimer cette recommendation locale ?')) return; if(removePendingByTempId(temp)){ $('#result').textContent = 'Recommendation locale supprimée'; renderPendingList(); } else { $('#result').textContent = 'Introuvable'; } return;
    }

    if(btn.classList.contains('server-delete')){
      const path = btn.dataset.path; if(!path){ $('#result').textContent = 'Impossible : pas de chemin connu pour cette proposition.'; return; } if(!confirm('Confirmer suppression sur le serveur ? Cette action est irréversible sur le serveur.')) return;
      try{ btn.disabled = true; $('#result').textContent = 'Suppression…'; const r = await fetch(WORKER_URL + '/delete', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ path }) }); let j = {}; try{ j = await r.json(); }catch(e){ j = { success: r.ok } }
        if(r.ok && j.success){ $('#result').textContent = '✔ Supprimé sur le serveur'; await loadAndRenderNow(true); } else { $('#result').textContent = 'Erreur suppression: ' + (j.error || r.status || 'inconnue'); btn.disabled = false; }
      }catch(err){ $('#result').textContent = 'Erreur réseau'; btn.disabled = false; debug(String(err)); }
    }
  });

  // ---------- FEATURED (simple-item block) ----------
  function renderFeaturedItem(item){
    const titleEl = document.getElementById('simple-title');
    const pseudoEl = document.getElementById('simple-pseudo');
    const authorEl = document.getElementById('simple-author');
    const descEl = document.getElementById('simple-description');

    if(!titleEl) return;

    titleEl.textContent = item.title || 'Sans titre';
    pseudoEl.textContent = 'Pseudo : ' + (item.pseudo || 'Anonyme');
    authorEl.textContent = 'Réalisateur : ' + (item.author || '—');

    if(item.contentHtml) descEl.innerHTML = item.contentHtml;
    else descEl.textContent = item.content || '';
  }

  // ready to copy — la fonction copyMarkdown() commence ici
  function copyMarkdown(){
    const title = document.getElementById('simple-title')?.textContent || 'Sans titre';
    const pseudo = document.getElementById('simple-pseudo')?.textContent.replace(/^Pseudo\s*:\s*/, '') || 'Anonyme';
    const author = document.getElementById('simple-author')?.textContent.replace(/^Réalisateur\s*:\s*/, '') || '—';
    const desc = document.getElementById('simple-description')?.textContent || '';

    const md = `# ${title}

**Pseudo:** ${pseudo}

**Réalisateur:** ${author}

**Description:**

${desc}`;
    navigator.clipboard?.writeText(md).then(()=>{ alert('Markdown copié dans le presse-papiers.'); },()=>{ alert('Impossible de copier — autorisez le presse-papiers.'); });
  }

  document.addEventListener('click', (e) => {
    if(e.target && e.target.id === 'print-simple') window.print();
    if(e.target && e.target.id === 'copy-simple') copyMarkdown();
  });

  // ---------- INIT ----------
  document.getElementById('year').textContent = new Date().getFullYear();
  // initial render: show pending from localStorage
  renderPendingList();
  // load server index asynchronously (does not override featured if LOCK_FEATURED)
  loadAndRenderNow().then(()=>{ if(pending.length) ensurePolling(); });
  setInterval(()=>{ loadAndRenderNow(); }, 5*60*1000);
  </script>
</body>
</html>

